[{
    "title": "Faire un serveur DHCP avec Windows server 16",
    "date": "",
    "description": "",
    "body": "Voici un tutoriel pour réaliser étape par étape un serveur DHCP avec Windows server 16\n Cliquez sur Gérer, puis sur Ajouter des rôles et fonctionnalités:\n    Suivant:     Sélectionner le type d’installation Installation basée sur un rôle ou une fonctionnalité:     Selectionner le serveur puis suivant:     Sélectionner le rôle Serveur DHCP:     Valider avec Suivant:     Ici vous pouvez constater toutes les fonctionnalités disponnible, dans notre cas nous n\u0026rsquo;en avons besoin d\u0026rsquo;aucune, cliquez sur Suivant:     :warning: Rappel: votre serveur doit avoir une IP fixée ! :warning: Cliquez sur suivant:     Vous pouvez maintenant l\u0026rsquo;installer:     Patienter pendant l\u0026rsquo;installation:     L\u0026rsquo;installation est maintenant finit, cliquez sur Fermer:    On peut maintenant aperçevoir un petit drapeau avec un :warning: car le serveur DHCP nécessite encore quelques manipulations\n Cliquez Terminer la configuration DHCP:     Valider:     Fermer:    Maintenant que le serveur DHCP est installé, il nous reste plus qu\u0026rsquo;à le configurer, pour ce faire\n Ouvrez le pannel de configuration du serveur DHCP, depuis le menu Outils, puis sélectionnez DHCP:    Nous allons créer une Nouvelle étendue qui aura pour effet de paramétrer une plage d\u0026rsquo;adresse IP disponible aux clients\n Clique droit sur IPv4 Clique gauche Nouvelle étendue\n    Suivant:\n    Nommez la nouvelle étendu:\n    Saisissez une plage d\u0026rsquo;adresse IP:\n    Vous pouvez sélectionner des adresses IP à exclure et même attribuer un retard pour transmettre un message DHCPOFFER:\n    Voici la durée du bail, vous pouvez également le modifier:\n    Sélectionner Oui dans le cas où vous avez une passerelle par défaut et/ou un DNS:\n    Saisir votre Passerelle par défaut:\n    Saisir votre DNS:\n    Activer l\u0026rsquo;étendue:\n    Terminer:\n    Nous pouvons constater que l\u0026rsquo;étendue a bien été créée:\n    On peut consulter les baux attribués:     Et voici la preuve que le serveur DHCP fonctionne, car il a attribué deux baux:\n   Note: on peut constater le BAD_ADDRESS pour l\u0026rsquo;adresse IP: 192.168.1.10 Pour la simple est bonne raison qu\u0026rsquo;un service DHCP était déjà actif sur un switch, et a donc provoqué un conflit !\n  Voilà :)\n",
    "ref": "/blog/windows_dhcp/"
  },{
    "title": "Cheatsheet Bash",
    "date": "",
    "description": "Petit carnet de note pour Bash",
    "body": " Cette cheatsheet est juste une réécriture partielle de cette cheatsheet: Source: devhints.io/bash\n Liste des variables définies dans un shell: $ set # Afficher les variables définie dans un shell $ unset MAVAR # Effacer une variable du shell Variable: Convention de nommage: écrire les variables en majuscule\nNAME=\u0026#34;John\u0026#34; echo $NAME echo \u0026#34;$NAME\u0026#34; echo \u0026#34;${NAME}!\u0026#34;  Variable portée: readonly LECTURESEULE=\u0026#34;ceci est une constante\u0026#34; # Constante  Variable ' \u0026quot; tick: DATE=date echo $DATE # date (affiche - \u0026#34;string\u0026#34;) ---------- DATE=\u0026#34;La date:\u0026#34;date echo $DATE # la date:date (affiche - \u0026#34;string\u0026#34;string) ---------- DATE=\u0026#39;La date:\u0026#39;date echo $DATE # La date:date (affiche - \u0026#34;string\u0026#34;string) ---------- DATE=\u0026#34;La date:\u0026#34;`date` echo $DATE # La date: samedi 22... (affiche - \u0026#34;string\u0026#34;`cmd`) ---------- DATE=\u0026#34;La date:`date`\u0026#34; echo $DATE # La date: samedi 22... (affiche - \u0026#34;string`cmd`\u0026#34;) ----------  Variable manipulation: STR=\u0026#34;HELLO WORLD!\u0026#34; echo ${STR,} #=\u0026gt; \u0026#34;hELLO WORLD!\u0026#34; (lowercase 1st letter) echo ${STR,,} #=\u0026gt; \u0026#34;hello world!\u0026#34; (all lowercase) STR=\u0026#34;hello world!\u0026#34; echo ${STR^} #=\u0026gt; \u0026#34;Hello world!\u0026#34; (uppercase 1st letter) echo ${STR^^} #=\u0026gt; \u0026#34;HELLO WORLD!\u0026#34; (all uppercase)  Variables traitment: name=\u0026#34;John\u0026#34; echo ${name} echo ${name/J/j} #=\u0026gt; \u0026#34;john\u0026#34; (substitution) echo ${name:0:2} #=\u0026gt; \u0026#34;Jo\u0026#34; (slicing) echo ${name::2} #=\u0026gt; \u0026#34;Jo\u0026#34; (slicing) echo ${name::-1} #=\u0026gt; \u0026#34;Joh\u0026#34; (slicing) echo ${name: -1} #=\u0026gt; \u0026#34;n\u0026#34; (slicing from right) -\u0026gt; ${$PATH_TO_FOLDER: -1} echo ${name:(-2):1} #=\u0026gt; \u0026#34;h\u0026#34; (slicing from right) echo ${food:-Cake} #=\u0026gt; $food or \u0026#34;Cake\u0026#34; length=2 echo ${name:0:length} #=\u0026gt; \u0026#34;Jo\u0026#34; echo ${#name} # 4 (size) STR=\u0026#34;/path/to/foo.cpp\u0026#34; echo ${STR%.cpp} # /path/to/foo echo ${STR%.cpp}.o # /path/to/foo.o echo ${STR##*.} # cpp (extension) echo ${STR##*/} # foo.cpp (basepath) echo ${STR#*/} # path/to/foo.cpp echo ${STR##*/} # foo.cpp echo ${STR/foo/bar} # /path/to/bar.cpp STR=\u0026#34;Hello world\u0026#34; echo ${STR:6:5} # \u0026#34;world\u0026#34; echo ${STR:-5:5} # \u0026#34;world\u0026#34; SRC=\u0026#34;/path/to/foo.cpp\u0026#34; BASE=${SRC##*/} #=\u0026gt; \u0026#34;foo.cpp\u0026#34; (basepath) DIR=${SRC%$BASE} #=\u0026gt; \u0026#34;/path/to/\u0026#34; (dirpath)  Variable math: echo $((5*5))  String quote: NAME=\u0026#34;John\u0026#34; echo \u0026#34;Hi $NAME\u0026#34; #=\u0026gt; Hi John echo \u0026#39;Hi $NAME\u0026#39; #=\u0026gt; Hi $NAME  Conditionals: if [[ -z \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is empty\u0026#34; elif [[ -n \u0026#34;$string\u0026#34; ]]; then echo \u0026#34;String is not empty\u0026#34; fi See Conditionals\n Conditional execution: git commit \u0026amp;\u0026amp; git push git commit || echo \u0026#34;Commit failed\u0026#34;  Condition négation: if [! -d /etc/fstab ] # Si \u0026#39;/etc/fstab\u0026#39; n\u0026#39;est pas un dossier  Condition (number):  Note that [[ is actually a command/program that returns either 0 (true) or 1 (false). Any program that obeys the same logic (like all base utils, such as grep(1) or ping(1)) can be used as condition, see examples.\n [[ -z STRING ]] # Empty string [[ -n STRING ]] # Not empty string [[ STRING == STRING ]] # Equal [[ STRING != STRING ]] # Not Equal [[ NUM -eq NUM ]] # == : Equal [[ NUM -ne NUM ]] # != : Not equal [[ NUM -lt NUM ]] # \u0026lt; : Less than [[ NUM -le NUM ]] # \u0026lt;= : Less than or equal [[ NUM -gt NUM ]] # \u0026gt; : Greater than [[ NUM -ge NUM ]] # \u0026gt;= : Greater than or equal [[ STRING =~ STRING ]] # Regexp (( NUM \u0026lt; NUM )) # Numeric conditions [[ -o noclobber ]] # If OPTIONNAME is   File condition: [[ -e FILE ]] # Exists: Le fichier existe [[ -r FILE ]] # Readable: Le fichier est lisible [[ -h FILE ]] # Symlink: ??? [[ -L FILE ]] # link: Le fichier est un lien [[ -d FILE ]] # Directory: Le fichier est un répertoire [[ -w FILE ]] # Writable: Le fichier est modifiable [[ -s FILE ]] # Size is \u0026gt; 0 bytes: ??? [[ -f FILE ]] # File: Le fichier est un fichier (PDV: unix) [[ -x FILE ]] # Executable: Le fichier est exécutable [[ FILE1 -nt FILE2 ]] # 1 is more recent than 2: FICHIER1 (+) récent que FICHIER2 [[ FILE1 -ot FILE2 ]] # 2 is more recent than 1: FICHIER1 (-) récent que FICHIER2 [[ FILE1 -ef FILE2 ]] # Same files: FICHIER1 == FICHIER2  Functions: get_name() { echo \u0026#34;John\u0026#34; } echo \u0026#34;You are $(get_name)\u0026#34; See more\n Shell execution echo \u0026#34;I\u0026#39;m in $(pwd)\u0026#34; echo \u0026#34;I\u0026#39;m in `pwd`\u0026#34; See more\n Work with arrays: echo ${Fruits[0]} # Element #0 echo ${Fruits[@]} # All elements, space-separated echo ${#Fruits[@]} # Number of elements echo ${#Fruits} # String length of the 1st element echo ${#Fruits[3]} # String length of the Nth element echo ${Fruits[@]:3:2} # Range (from position 3, length 2) Fruits=(\u0026#34;${Fruits[@]}\u0026#34; \u0026#34;Watermelon\u0026#34;) # Push Fruits+=(\u0026#39;Watermelon\u0026#39;) # Also Push Fruits=( ${Fruits[@]/Ap*/} ) # Remove by regex match unset Fruits[2] # Remove one item Fruits=(\u0026#34;${Fruits[@]}\u0026#34;) # Duplicate Fruits=(\u0026#34;${Fruits[@]}\u0026#34; \u0026#34;${Veggies[@]}\u0026#34;) # Concatenate lines=(`cat \u0026#34;logfile\u0026#34;`) # Read from file  Return values: ./monscript.sh var1 test2 valeur3 $0 # Nom du script \u0026#34;./monscript\u0026#34; $* # Tous les paramètres sous formes d\u0026#39;un seul arguments: \u0026#34;var1 test2 valeur3\u0026#34; $@ # Tous les paramètres sous formes d\u0026#39;un argument par paramètres \u0026#34;var1\u0026#34; \u0026#34;test2\u0026#34; \u0026#34;valeur3\u0026#34; $# # Nombre de paramètres dans l\u0026#39;exemple : 3 $? # Code de retour (0: OK, 1 à 128: Erreur) $$ # PID du shell qui execute le script $! # PId du dernier processus lancé en arrière-plan  Moulinette - Check syntaxe: bash -n monscript.sh ",
    "ref": "/blog/cheatsheet_bash/"
  },{
    "title": "Comment mettre une IP fixe/dynamique sur Linux",
    "date": "",
    "description": "IP statique ou IP DHCP ?",
    "body": "Voici les modèles à suivre pour mettre une adresse IP en statique/fixée ou dynamique/DHCP\nIP statique/fixe: auto eth0 iface eth0 inet static address 192.168.1.101 # L\u0026#39;adresse IP netmask 255.255.255.0 # Le masque de réseau gateway 192.168.1.1 # La passerelle par défaut  IP DHCP: auto eth0 iface eth0 inet dhcp   Ne pas oublier de redemarrer le service bien sur : Debian:  sudo /etc/init.d/networking restart systemctl restart networking   Ubuntu:  service networking restart     D\u0026rsquo;ailleurs si les termes vous intrigue et que vous aimeriez en savoir plus, il y a une doc complète ici\n",
    "ref": "/blog/linux_mettre_ip_fixe_dynamique/"
  },{
    "title": "SSH autocompletion",
    "date": "",
    "description": "Ajouter "l'autocompletion" pour SSH",
    "body": "Vous savez tout comme moi qu\u0026rsquo;il peut-être épuisant de devoir retaper l\u0026rsquo;adresse IP ou le Host de votre serveur\nLa solution: ajouter l\u0026rsquo;autocomplete de Hostname pour SSH !\n Voici ce que ça donne:   Pour ce faire il nous faut déjà remplir le fichier ~/.ssh/config avec nos serveurs, voici un exemple:  ########################################\r######## Serveur de production #########\r########################################\rHost ServeurDeProduction\rHostname 127.0.0.1\rUser root\rIdentityFile ~/.ssh/prod\r########################################\r######## Serveur de qualif #############\r########################################\rHost ServeurDeQualif\rHostname 127.0.0.1\rUser root\rIdentityFile ~/.ssh/qualif\r#########################################\r######## Serveur de tata odette #########\r#########################################\rHost tata_odette\rHostname 127.0.0.1\rUser root\rIdentityFile ~/.ssh/tata_odette\rAjoutez le script d\u0026rsquo;autocompletion dans ce nouveau fichier:\n$ vim /etc/bash_autocompletion.d/ssh\n_ssh(){ local cur prev opts COMPREPLY=() cur=\u0026#34;${COMP_WORDS[COMP_CWORD]}\u0026#34; prev=\u0026#34;${COMP_WORDS[COMP_CWORD-1]}\u0026#34; opts=$(grep \u0026#39;^Host\u0026#39; ~/.ssh/config ~/.ssh/config.d/* 2\u0026gt;/dev/null | grep -v \u0026#39;[?*]\u0026#39; | cut -d \u0026#39; \u0026#39; -f 2-) COMPREPLY=( $(compgen -W \u0026#34;$opts\u0026#34; -- ${cur}) ) return 0 } complete -F _ssh ssh  Il faut ensuite indiquer au ~/.bashrc de charger cette fonction  $ vim ~/.bashrc\n Ajouter tout à la fin du fichier cette ligne:  . /etc/bash_completion.d/ssh  Voilà, vous pouvez maintenant redémarrer votre terminal ou recharger votre configuration avec:  . ~/.bashrc\n",
    "ref": "/blog/ssh_autocompletion/"
  },{
    "title": "Comment réparer une clef USB",
    "date": "",
    "description": "Guide de réparation d'une clef USB avec Windows",
    "body": "Réparer une clef USB Windows:  Il arrive des fois, qu\u0026rsquo;après avoir créée une clef USB bootable (Linux, Windows\u0026hellip;) on se retrouve avec un espace de stockage perdu\u0026hellip;\nDans mon cas, je voulais reformater ma clef USB de 8 Go sur laquelle j\u0026rsquo;avais monté un ISO Debian, sauf que l\u0026rsquo;outil de formatage Windows indiquait sa capacité totale à 390 Ko !\nAlors que l\u0026rsquo;outil de Gestion des disques Windows indiquait bien 8Go:\n comment faire pour récupérer ce volume perdu ?   Dans le menu Démarrer, recherchez et lancez diskpart\n  Tapez list disk pour voir tous les volumes de disque actuels sur votre système   Branchez votre clé USB et tapez à nouveau list disk. Notez le nouveau volume listé   Une fois le volume identifié:   Tapez le numéro de disque sélectionné # où # correspond au numéro de volume de votre clé USB\n  Tapez clean pour effacer le volume de toutes les partitions.\n  Tapez create partition primary pour créer une nouvelle partition avec tout l\u0026rsquo;espace non alloué.\n  Tapez exit pour terminer.\n  Vous pouvez maintenant aller dans l\u0026rsquo;explorateur de fichier Windows, double cliquer sur votre clef USB\n  L\u0026rsquo;outil de formatage se lancera:\n   Procéder au formatage   Et voici votre clef réparée:  ",
    "ref": "/blog/reparer_clef_usb_windows/"
  },{
    "title": "Contact",
    "date": "",
    "description": "",
    "body": "",
    "ref": "/contact/"
  },{
    "title": "À propos de ...",
    "date": "",
    "description": "",
    "body": "Qui suis-je ? Je m\u0026rsquo;appelle Hugo Grosot j\u0026rsquo;ai 24 ans et je suis actuellement en deuxième année de BTS SIO SISR en alternance chez Auchan Retail France, vous pourrez d\u0026rsquo;ailleurs en savoir plus sur ma page LinkedIn\nPourquoi ce site ? J\u0026rsquo;ai créé ce site dans l\u0026rsquo;objectif de proposer des notes et tutoriels autour de plusieurs domaines, principalement dans l\u0026rsquo;administration Linux/Windows et sur le réseau, mais il est fort probable que je propose aussi du contenu plus général mais toujours axé sur l\u0026rsquo;informatique\n",
    "ref": "/a-propos/"
  }]
